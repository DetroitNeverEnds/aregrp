name: Deploy Testing

on:
    workflow_call:
        secrets:
            VPS_HOST:
                required: true
            VPS_USER:
                required: true
            VPS_SSH_KEY:
                required: true
            ENV_FILE:
                required: true
            ENV_POSTGRES_FILE:
                required: true
    # Старые условия (закомментированы):
    # pull_request:
    #     branches: [main]
    #     paths:
    #         - "**/*"
    # workflow_dispatch:
    
    # Новые условия: запуск при push в main
    push:
        branches: [main]

env:
    # Имя образа: ghcr.io/ваш-юзер/ваш-репо
    REGISTRY: ghcr.io
    REGISTRY_PREFIX: ghcr.io/detroitneverends/aregrp/
    # TAG формируется в зависимости от типа запуска:
    # - Pull Request: pr-{номер}-{номер запуска}
    # - workflow_dispatch: {короткий хеш коммита} (первые 7 символов)
    # - Push: {имя ветки}-{номер запуска}
    TAG: ${{ github.event.pull_request.number && format('pr-{0}-{1}', github.event.pull_request.number, github.run_number) || (github.event_name == 'workflow_dispatch' && github.sha) || format('{0}-{1}', github.ref_name, github.run_number) }}

jobs:
    build-and-push:
        name: Build and Push
        runs-on: ubuntu-latest
        permissions:
            contents: read
            packages: write
        steps:
            - name: Checkout code
              id: checkout
              uses: actions/checkout@v4

            - name: Set up Docker Buildx
              id: setup-buildx
              uses: docker/setup-buildx-action@v3

            - name: Log in to the Container registry
              id: docker-login
              uses: docker/login-action@v3
              with:
                  registry: ${{ env.REGISTRY }}
                  username: ${{ github.actor }}
                  password: ${{ secrets.GITHUB_TOKEN }}

            # Создаем пустые .env файлы только для валидации конфигурации docker-compose
            # Docker Compose проверяет наличие файлов из env_file даже при build
            # Эти файлы не попадут в образ благодаря .dockerignore
            # Реальные значения будут созданы на сервере из GitHub Secrets
            - name: Create temporary .env files for build validation
              id: create-env-files
              run: |
                  mkdir -p backend
                  touch backend/.env backend/.env.postgres
                  echo "Created temporary .env files for docker-compose validation"

            - name: Build and Push
              id: build-push
              env:
                  REGISTRY_PREFIX: ${{ env.REGISTRY_PREFIX }}
                  TAG: ${{ env.TAG }}
              run: docker compose build && docker compose push
    deploy:
        name: Deploy
        needs: build-and-push
        runs-on: ubuntu-latest

        steps:
            - name: Checkout code
              id: checkout
              uses: actions/checkout@v4

            - name: Secrets diagnostics
              id: secrets-check
              run: |
                  test -z "${{ secrets.ENV_FILE }}" && echo "ENV_FILE EMPTY" || echo "ENV_FILE PRESENT"
                  test -z "${{ secrets.ENV_POSTGRES_FILE }}" && echo "ENV_POSTGRES_FILE EMPTY" || echo "ENV_POSTGRES_FILE PRESENT"

            - name: Copy docker-compose via SCP
              id: copy-compose
              uses: appleboy/scp-action@master
              with:
                  host: ${{ secrets.VPS_HOST }}
                  username: ${{ secrets.VPS_USER }}
                  key: ${{ secrets.VPS_SSH_KEY }}
                  source: "docker-compose.yml"
                  target: "/home/${{ secrets.VPS_USER }}/aregrp/"

            - name: Create environment files from secrets
              id: create-env-files
              uses: appleboy/ssh-action@master
              env:
                  ENV_FILE_CONTENT: ${{ secrets.ENV_FILE }}
                  ENV_POSTGRES_FILE_CONTENT: ${{ secrets.ENV_POSTGRES_FILE }}
              with:
                  host: ${{ secrets.VPS_HOST }}
                  username: ${{ secrets.VPS_USER }}
                  key: ${{ secrets.VPS_SSH_KEY }}
                  script: |
                      cd ~/aregrp/
                      echo "Current directory: $(pwd)"
                      mkdir -p backend
                      
                      # Создаем backend/.env из секрета
                      if [ -n "$ENV_FILE_CONTENT" ]; then
                          echo "$ENV_FILE_CONTENT" > backend/.env
                          echo "✅ Created backend/.env from GitHub Secrets"
                          echo "File size: $(wc -c < backend/.env) bytes, lines: $(wc -l < backend/.env)"
                          # Показываем первые несколько строк (без секретов, только ключи)
                          echo "First few lines:"
                          head -n 3 backend/.env | sed 's/=.*/=***/' || true
                      else
                          echo "⚠️  ERROR: ENV_FILE secret is not set!"
                          echo "Please configure ENV_FILE secret in:"
                          echo "  - Repository Settings → Secrets and variables → Actions (for pull_request/workflow_dispatch)"
                          echo "  - Or pass it via workflow_call secrets (for reusable workflows)"
                          echo ""
                          echo "Creating empty backend/.env file (containers will not work properly!)"
                          touch backend/.env
                      fi
                      
                      # Создаем backend/.env.postgres из секрета
                      if [ -n "$ENV_POSTGRES_FILE_CONTENT" ]; then
                          echo "$ENV_POSTGRES_FILE_CONTENT" > backend/.env.postgres
                          echo "✅ Created backend/.env.postgres from GitHub Secrets"
                          echo "File size: $(wc -c < backend/.env.postgres) bytes, lines: $(wc -l < backend/.env.postgres)"
                          # Показываем первые несколько строк (без секретов, только ключи)
                          echo "First few lines:"
                          head -n 3 backend/.env.postgres | sed 's/=.*/=***/' || true
                      else
                          echo "⚠️  ERROR: ENV_POSTGRES_FILE secret is not set!"
                          echo "Please configure ENV_POSTGRES_FILE secret in:"
                          echo "  - Repository Settings → Secrets and variables → Actions (for pull_request/workflow_dispatch)"
                          echo "  - Or pass it via workflow_call secrets (for reusable workflows)"
                          echo ""
                          echo "Creating empty backend/.env.postgres file (database will not work!)"
                          touch backend/.env.postgres
                      fi
                      
                      # Проверяем, что файлы созданы
                      echo ""
                      echo "Verifying files exist:"
                      ls -lh backend/.env* || echo "ERROR: .env files not found!"
                      echo ""
                      echo "Full path to files:"
                      echo "  $(pwd)/backend/.env"
                      echo "  $(pwd)/backend/.env.postgres"
                      
                      # Проверяем, что файлы не пустые
                      if [ ! -s backend/.env ]; then
                          echo "❌ ERROR: backend/.env is empty! Containers will fail!"
                          exit 1
                      fi
                      if [ ! -s backend/.env.postgres ]; then
                          echo "❌ ERROR: backend/.env.postgres is empty! Database will fail!"
                          exit 1
                      fi

            - name: Execute remote ssh commands
              id: deploy-containers
              uses: appleboy/ssh-action@master
              with:
                  host: ${{ secrets.VPS_HOST }}
                  username: ${{ secrets.VPS_USER }}
                  key: ${{ secrets.VPS_SSH_KEY }}
                  script: |
                      cd ~/aregrp/

                      # Проверяем, что .env файлы созданы и доступны
                      echo "Checking .env files before starting containers..."
                      if [ -f backend/.env ]; then
                          echo "✅ backend/.env exists ($(wc -l < backend/.env) lines)"
                          echo "First line: $(head -n 1 backend/.env | cut -c1-50)..."
                      else
                          echo "❌ ERROR: backend/.env NOT FOUND!"
                          exit 1
                      fi
                      
                      if [ -f backend/.env.postgres ]; then
                          echo "✅ backend/.env.postgres exists ($(wc -l < backend/.env.postgres) lines)"
                          echo "First line: $(head -n 1 backend/.env.postgres | cut -c1-50)..."
                      else
                          echo "❌ ERROR: backend/.env.postgres NOT FOUND!"
                          exit 1
                      fi
                      
                      # Показываем текущую директорию и структуру
                      echo "Current directory: $(pwd)"
                      echo "Files in backend/:"
                      ls -la backend/ | grep -E '\.env' || echo "No .env files found!"

                      # Логинимся в реестр GitHub на самом VPS, чтобы скачать приватный образ
                      echo ${{ secrets.GITHUB_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin

                      # Экспортируем переменные окружения для docker-compose
                      export REGISTRY_PREFIX=${{ env.REGISTRY_PREFIX }}
                      export TAG=${{ env.TAG }}

                      # Останавливаем, скачиваем и запускаем
                      docker compose pull
                      docker compose up -d --remove-orphans

                      # Проверяем, что контейнеры запустились и переменные окружения загружены
                      echo "Checking if containers are running..."
                      docker compose ps
                      
                      # Чистим старые неиспользуемые образы, чтобы не забить диск
                      docker image prune -f
